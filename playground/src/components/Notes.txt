Save vor Speichern







App.jsx


import React, { useEffect, useState } from 'react'
import {
  DndContext,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core'

import TreePlaygroundView from './components/TreePlaygroundView'
import TreeEditorView from './components/TreeEditorView'
import TreeSidebar from './components/TreeSidebar'

function App() {
  const [units, setUnits] = useState([])
  const [loading, setLoading] = useState(true)

  const [projects, setProjects] = useState({})
  const [activeProject, setActiveProject] = useState("")
  const [structure, setStructure] = useState([])
  const [playground, setPlayground] = useState([])

  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 5 } }))
  const STORAGE_KEY = "notedeck_projects_v1"

  const isModified = () => {
    const saved = projects[activeProject]
    if (!saved) return false
    return (
      JSON.stringify(saved.structure) !== JSON.stringify(structure) ||
      JSON.stringify(saved.playground) !== JSON.stringify(playground)
    )
  }

  const saveProjectsToStorage = (updatedProjects, selectedProject) => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      projects: updatedProjects,
      activeProject: selectedProject
    }))
  }

  const saveCurrentProject = () => {
    if (!activeProject) return alert("‚ö†Ô∏è Kein aktives Projekt ausgew√§hlt.")
    const updated = {
      ...projects,
      [activeProject]: {
        structure,
        playground,
        timestamp: Date.now()
      }
    }
    setProjects(updated)
    saveProjectsToStorage(updated, activeProject)
    alert(`‚úÖ Projekt '${activeProject}' gespeichert.`)
  }

  const loadProject = (name) => {
    const entry = projects[name]
    if (!entry) return
    setStructure(entry.structure || [])
    setPlayground(entry.playground || [])
    setActiveProject(name)
    saveProjectsToStorage(projects, name)
  }

  const deleteProject = (name) => {
    if (!window.confirm(`‚ùå Projekt '${name}' wirklich l√∂schen?`)) return
    const copy = { ...projects }
    delete copy[name]
    const nextActive = Object.keys(copy)[0] || ""
    setProjects(copy)
    setActiveProject(nextActive)
    setStructure(copy[nextActive]?.structure || [])
    setPlayground(copy[nextActive]?.playground || [])
    saveProjectsToStorage(copy, nextActive)
  }

  const createNewProject = () => {
    const name = prompt("üîß Neuer Projektname:")
    if (!name || name.trim() === "") return
    if (projects[name]) return alert("‚ùó Projektname existiert bereits.")
    const updated = {
      ...projects,
      [name]: { structure: [], playground: [], timestamp: Date.now() }
    }
    setProjects(updated)
    setActiveProject(name)
    setStructure([])
    setPlayground([])
    saveProjectsToStorage(updated, name)
  }

  const renameProject = () => {
    if (!activeProject || !projects[activeProject]) return
    const newName = prompt("üìù Neuer Projektname:", activeProject)
    if (!newName || newName.trim() === "") return
    if (projects[newName] && newName !== activeProject) {
      alert("‚ùó Ein Projekt mit diesem Namen existiert bereits.")
      return
    }

    const updated = { ...projects }
    updated[newName] = updated[activeProject]
    if (newName !== activeProject) delete updated[activeProject]

    setProjects(updated)
    setActiveProject(newName)
    saveProjectsToStorage(updated, newName)
  }

  const resetToSavedProjectState = () => {
    if (!activeProject || !projects[activeProject]) {
      alert("‚ö†Ô∏è Kein gespeicherter Stand verf√ºgbar.")
      return
    }

    const saved = projects[activeProject]
    setStructure(saved.structure || [])
    setPlayground(saved.playground || [])
    alert("‚Ü© Projekt auf gespeicherten Zustand zur√ºckgesetzt.")
  }

  const handleDragEnd = ({ active, over }) => {
    if (!active || !over || active.id === over.id) return

    const draggedIDs = active?.data?.current?.draggedIDs || [active.id.split('__').pop()]
    const targetSubID = over.id.includes('__') ? over.id.split('__')[0] : over.id
    const targetIndexUnit = over.id.includes('__') ? over.id.split('__')[1] : null

    setStructure(prev =>
      prev.map(section => ({
        ...section,
        subsections: section.subsections.map(sub => {
          let current = [...sub.unitIDs]
          const fromIndex = current.indexOf(draggedIDs[0])
          const toIndex = targetIndexUnit ? current.indexOf(targetIndexUnit) : current.length

          if (fromIndex === -1 && sub.id !== targetSubID) {
            return {
              ...sub,
              unitIDs: current.filter(id => !draggedIDs.includes(id))
            }
          }

          let updated = current.filter(id => !draggedIDs.includes(id))
          let insertAt = toIndex
          if (fromIndex < toIndex) {
            insertAt = toIndex - draggedIDs.length + 1
          }

          if (sub.id === targetSubID) {
            draggedIDs.forEach((id, i) => {
              updated.splice(insertAt + i, 0, id)
            })
          }

          return { ...sub, unitIDs: updated }
        })
      }))
    )
  }

  useEffect(() => {
    fetch('http://127.0.0.1:8000/units')
      .then(res => res.json())
      .then(data => {
        setUnits(data)
        setLoading(false)
      })
      .catch(err => {
        console.error('Fehler beim Laden der Units:', err)
        setLoading(false)
      })

    const raw = localStorage.getItem(STORAGE_KEY)
    if (raw) {
      const parsed = JSON.parse(raw)
      setProjects(parsed.projects || {})
      setActiveProject(parsed.activeProject || "")
      if (parsed.activeProject && parsed.projects?.[parsed.activeProject]) {
        setStructure(parsed.projects[parsed.activeProject].structure || [])
        setPlayground(parsed.projects[parsed.activeProject].playground || [])
      }
    }
  }, [])

  return (
    <DndContext sensors={sensors} onDragEnd={handleDragEnd}>
      <div style={{ height: '100vh', width: '100vw', backgroundColor: '#1a1a1a', color: '#eee', display: 'flex', flexDirection: 'column' }}>
        
        {/* Topbar */}
        <div style={{ padding: '0.5rem 1rem', display: 'flex', alignItems: 'center', gap: '0.7rem', borderBottom: '1px solid #444', backgroundColor: '#111' }}>
          <span>Projekt:</span>
          <select
            value={activeProject}
            onChange={e => loadProject(e.target.value)}
            style={{ padding: '0.2rem 0.4rem', backgroundColor: '#222', color: '#eee', border: '1px solid #555' }}
          >
            {Object.keys(projects).map(name => (
              <option key={name} value={name}>{name}</option>
            ))}
          </select>
          <button onClick={renameProject} style={topbarButton}>üìù Umbenennen</button>
          <button onClick={createNewProject} style={topbarButton}>‚ûï Neu</button>
          <button onClick={saveCurrentProject} style={topbarButton}>üíæ Speichern</button>
          <button onClick={() => loadProject(activeProject)} style={topbarButton}>üìÇ Laden</button>
          <button onClick={resetToSavedProjectState} style={topbarButton}>‚Ü© Wiederherstellen</button>
          <button onClick={() => deleteProject(activeProject)} style={topbarButton}>üóëÔ∏è L√∂schen</button>
        </div>

        {/* Main content area */}
        <div style={{ display: 'flex', flexGrow: 1 }}>
          <div style={{ width: '20%', borderRight: '1px solid #333', padding: '1rem', overflowY: 'auto' }}>
            <TreeSidebar units={units} playground={playground} setPlayground={setPlayground} />
          </div>
          <div style={{ width: '35%', padding: '1.5rem', overflowY: 'auto' }}>
            <h2 style={{ marginBottom: '1rem' }}>Ausgew√§hlte Einheiten (Tree)</h2>
            {loading ? (
              <p>‚è≥ Lade Inhalte ‚Ä¶</p>
            ) : (
              <TreePlaygroundView
                playground={playground}
                units={units}
                selectedIDs={new Set()}
                setSelectedIDs={() => {}}
                lastSelectedIndex={null}
                setLastSelectedIndex={() => {}}
                setPlayground={setPlayground}
              />
            )}
          </div>
          <div style={{ width: '45%', padding: '1.5rem', borderLeft: '1px solid #333', overflowY: 'auto' }}>
            <h2 style={{ marginBottom: '1rem' }}>üì¶ Struktur (Tree)</h2>
            <TreeEditorView
              structure={structure}
              setStructure={setStructure}
              selectedEditorIDs={new Set()}
              setSelectedEditorIDs={() => {}}
              lastSelectedEditorIndex={null}
              setLastSelectedEditorIndex={() => {}}
              units={units}
              updateStructure={setStructure}
            />
          </div>
        </div>
      </div>
    </DndContext>
  )
}

const topbarButton = {
  backgroundColor: '#333',
  color: '#eee',
  padding: '0.3rem 0.6rem',
  borderRadius: '4px',
  border: '1px solid #555',
  fontSize: '0.75rem',
  cursor: 'pointer'
}

export default App






View




















---------------------------------------


App

// src/App.jsx
import { useEffect, useState } from 'react'
import {
  DndContext,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core'

import TreePlaygroundView from './components/TreePlaygroundView'
import TreeEditorView from './components/TreeEditorView'
import TreeSidebar from './components/TreeSidebar'

function App() {
  const [units, setUnits] = useState([])
  const [loading, setLoading] = useState(true)
  const [playground, setPlayground] = useState([])
  const [structure, setStructure] = useState([])

  const [selectedPlaygroundIDs, setSelectedPlaygroundIDs] = useState(new Set())
  const [selectedEditorIDs, setSelectedEditorIDs] = useState(new Set())
  const [lastSelectedPlaygroundIndex, setLastSelectedPlaygroundIndex] = useState(null)
  const [lastSelectedEditorIndex, setLastSelectedEditorIndex] = useState(null)

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 5 },
    })
  )

  const normalizeUnitID = (id) => {
    if (id.includes('____drop__')) return id.split('____drop__')[1]
    if (id.includes('__drop__')) return id.split('__drop__')[1]
    if (id.includes('__')) return id.split('__')[1]
    return id
  }

  const handleDragEnd = ({ active, over }) => {
    if (!active || !over || active.id === over.id) return
  
    const activeType = active.data.current?.type
    const overId = over.id
    const overType = over.data?.current?.type
  
    // === 1. Verschiebe Sections ===
    if (activeType === 'section') {
      setStructure(prev => {
        const oldIndex = prev.findIndex(s => s.id === active.id)
        const newIndex = prev.findIndex(s => s.id === overId)
        if (oldIndex === -1 || newIndex === -1) return prev
  
        const updated = [...prev]
        const [moved] = updated.splice(oldIndex, 1)
        updated.splice(newIndex, 0, moved)
        return updated
      })
    }
  
    // === 2. Verschiebe Subsections innerhalb einer Section ===
    else if (activeType === 'subsection') {
      const parentId = active.data.current?.parentId
      setStructure(prev =>
        prev.map(section => {
          if (section.id !== parentId) return section
  
          const subs = [...section.subsections]
          const oldIndex = subs.findIndex(sub => sub.id === active.id)
          const newIndex = subs.findIndex(sub => sub.id === overId)
          if (oldIndex === -1 || newIndex === -1) return section
  
          const [moved] = subs.splice(oldIndex, 1)
          subs.splice(newIndex, 0, moved)
  
          return { ...section, subsections: subs }
        })
      )
    }
  
    // === 3. Verschiebe Units innerhalb einer Subsection ===
    else {
      const draggedIDs =
        active?.data?.current?.draggedIDs ||
        (selectedPlaygroundIDs.size > 0
          ? Array.from(selectedPlaygroundIDs)
          : selectedEditorIDs.size > 0
          ? Array.from(selectedEditorIDs)
          : [normalizeUnitID(active.id)])
  
      const targetSubID = over.id.includes('__')
        ? over.id.split('__')[0]
        : over.id
  
      const targetIndexUnit = over.id.includes('__')
        ? normalizeUnitID(over.id)
        : null
  
      setStructure(prev =>
        prev.map(section => ({
          ...section,
          subsections: section.subsections.map(sub => {
            let current = [...sub.unitIDs]
            const fromIndex = current.indexOf(draggedIDs[0])
            const toIndex = targetIndexUnit ? current.indexOf(targetIndexUnit) : current.length
  
            if (fromIndex === -1 && sub.id !== targetSubID) {
              // Entferne von anderen Subsections
              return {
                ...sub,
                unitIDs: current.filter(id => !draggedIDs.includes(id))
              }
            }
  
            let updated = current.filter(id => !draggedIDs.includes(id))
            let insertAt = toIndex
            if (fromIndex < toIndex) {
              insertAt = toIndex - draggedIDs.length + 1
            }
  
            if (sub.id === targetSubID) {
              draggedIDs.forEach((id, i) => {
                updated.splice(insertAt + i, 0, id)
              })
            }
  
            return { ...sub, unitIDs: updated }
          })
        }))
      )
    }
  
    // Reset selection
    setSelectedPlaygroundIDs(new Set())
    setSelectedEditorIDs(new Set())
    setLastSelectedPlaygroundIndex(null)
    setLastSelectedEditorIndex(null)
  }
  
  


  useEffect(() => {
    fetch('http://127.0.0.1:8000/units')
      .then(res => res.json())
      .then(data => {
        setUnits(data)
        setLoading(false)
      })
      .catch(err => {
        console.error('Fehler beim Laden der Units:', err)
        setLoading(false)
      })
  }, [])

  return (
    <DndContext
      sensors={sensors}
      onDragEnd={handleDragEnd}
    >
      <div
        style={{
          display: 'flex',
          height: '100vh',
          width: '100vw',
          backgroundColor: '#1a1a1a',
          color: '#eee',
        }}
      >
        <div style={{ width: '25%', borderRight: '1px solid #333', padding: '1rem', overflowY: 'auto' }}>
          <TreeSidebar units={units} playground={playground} setPlayground={setPlayground} />
        </div>
        <div style={{ width: '40%', padding: '1.5rem', overflowY: 'auto' }}>
          <h2 style={{ marginBottom: '1rem' }}>Ausgew√§hlte Einheiten (Tree)</h2>
          {loading ? (
            <p>‚è≥ Lade Inhalte ‚Ä¶</p>
          ) : (
            <TreePlaygroundView
              playground={playground}
              units={units}
              selectedIDs={selectedPlaygroundIDs}
              setSelectedIDs={setSelectedPlaygroundIDs}
              lastSelectedIndex={lastSelectedPlaygroundIndex}
              setLastSelectedIndex={setLastSelectedPlaygroundIndex}
              setPlayground={setPlayground}  // ‚¨ÖÔ∏è hinzuf√ºgen
            />
          )}
        </div>
        <div style={{ width: '35%', padding: '1.5rem', borderLeft: '1px solid #333', overflowY: 'auto' }}>
          <h2 style={{ marginBottom: '1rem' }}>üì¶ Struktur (Tree)</h2>
          <TreeEditorView
            structure={structure}
            setStructure={setStructure}
            selectedEditorIDs={selectedEditorIDs}
            setSelectedEditorIDs={setSelectedEditorIDs}
            lastSelectedEditorIndex={lastSelectedEditorIndex}
            setLastSelectedEditorIndex={setLastSelectedEditorIndex}
            units={units}
          />
        </div>
      </div>
    </DndContext>
  )
}

export default App









Editor

import { useState } from 'react'
import {
  useSortable,
  SortableContext,
  verticalListSortingStrategy
} from '@dnd-kit/sortable'
import { useDroppable } from '@dnd-kit/core'
import { CSS } from '@dnd-kit/utilities'

export default function TreeEditorView({
  structure,
  setStructure,
  units,
  selectedEditorIDs,
  setSelectedEditorIDs,
  lastSelectedEditorIndex,
  setLastSelectedEditorIndex
}) {
  const [newSectionName, setNewSectionName] = useState('')
  const [subInputs, setSubInputs] = useState({})
  const [collapsedSections, setCollapsedSections] = useState(new Set())
  const [collapsedSubsections, setCollapsedSubsections] = useState(new Set())

  const toggleCollapseSection = (id) => {
    setCollapsedSections(prev => {
      const next = new Set(prev)
      next.has(id) ? next.delete(id) : next.add(id)
      return next
    })
  }

  const toggleCollapseSubsection = (id) => {
    setCollapsedSubsections(prev => {
      const next = new Set(prev)
      next.has(id) ? next.delete(id) : next.add(id)
      return next
    })
  }

  const getUnitByID = (id) => units.find(u => u.UnitID === id)

  const toggleSelection = (fullID, index, shift = false, allIDs = []) => {
    setSelectedEditorIDs(prev => {
      const next = new Set(prev)
      if (shift && lastSelectedEditorIndex !== null) {
        const start = Math.min(lastSelectedEditorIndex, index)
        const end = Math.max(lastSelectedEditorIndex, index)
        for (let i = start; i <= end; i++) next.add(allIDs[i])
      } else {
        next.has(fullID) ? next.delete(fullID) : next.add(fullID)
        setLastSelectedEditorIndex(index)
      }
      return next
    })
  }

  const addSection = () => {
    if (!newSectionName.trim()) return
    setStructure([...structure, {
      id: `sec-${Date.now()}`,
      name: newSectionName,
      subsections: []
    }])
    setNewSectionName('')
  }

  return (
    <div style={{ fontFamily: 'monospace', fontSize: '0.78rem', color: '#eee' }}>
      <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.7rem' }}>
        <input
          type="text"
          value={newSectionName}
          onChange={e => setNewSectionName(e.target.value)}
          onKeyDown={(e) => { if (e.key === 'Enter') addSection() }}
          placeholder="Neue Section"
          style={{ backgroundColor: '#111', color: '#eee', padding: '0.2rem', fontSize: '0.75rem', flex: 1 }}
        />
        <button onClick={addSection} style={styles.button}>Add</button>
      </div>

      <SortableContext items={structure.map(s => s.id)} strategy={verticalListSortingStrategy}>
        {structure.map(section => (
          <SortableSection
            key={section.id}
            section={section}
            setStructure={setStructure}
            subInputs={subInputs}
            setSubInputs={setSubInputs}
            getUnitByID={getUnitByID}
            selectedEditorIDs={selectedEditorIDs}
            toggleSelection={toggleSelection}
            lastSelectedEditorIndex={lastSelectedEditorIndex}
            setLastSelectedEditorIndex={setLastSelectedEditorIndex}
            collapsedSections={collapsedSections}
            collapsedSubsections={collapsedSubsections}
            toggleCollapseSection={toggleCollapseSection}
            toggleCollapseSubsection={toggleCollapseSubsection}
          />
        ))}
      </SortableContext>
    </div>
  )
}

function SortableSection({
  section,
  setStructure,
  subInputs,
  setSubInputs,
  getUnitByID,
  selectedEditorIDs,
  toggleSelection,
  lastSelectedEditorIndex,
  setLastSelectedEditorIndex,
  collapsedSections,
  collapsedSubsections,
  toggleCollapseSection,
  toggleCollapseSubsection
}) {
  const {
    setNodeRef,
    transform,
    transition,
    attributes,
    listeners,
    isDragging
  } = useSortable({
    id: section.id,
    data: { type: 'section' }
  })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    marginBottom: '1.5rem'
  }

  const isCollapsed = collapsedSections.has(section.id)

  return (
    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>
      <div
        style={styles.section}
        onClick={() => toggleCollapseSection(section.id)}
      >
        <span style={{ cursor: 'pointer', marginRight: '0.4rem' }}>
          {isCollapsed ? '‚ñ∂' : '‚ñº'}
        </span>
        {section.name}
      </div>

      {!isCollapsed && (
        <>
          <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.3rem', marginLeft: '1rem' }}>
            <input
              type="text"
              value={subInputs[section.id] || ''}
              onChange={e => setSubInputs({ ...subInputs, [section.id]: e.target.value })}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  const name = subInputs[section.id] || ''
                  setSubInputs({ ...subInputs, [section.id]: '' })
                  setStructure(prev =>
                    prev.map(s =>
                      s.id === section.id
                        ? { ...s, subsections: [...s.subsections, { id: `sub-${Date.now()}`, name, unitIDs: [] }] }
                        : s
                    )
                  )
                }
              }}
              placeholder="Neue Subsection"
              style={{ backgroundColor: '#111', color: '#eee', padding: '0.2rem', fontSize: '0.72rem', flex: 1 }}
            />
            <button
              onClick={() => {
                const name = subInputs[section.id] || ''
                setSubInputs({ ...subInputs, [section.id]: '' })
                setStructure(prev =>
                  prev.map(s =>
                    s.id === section.id
                      ? { ...s, subsections: [...s.subsections, { id: `sub-${Date.now()}`, name, unitIDs: [] }] }
                      : s
                  )
                )
              }}
              style={styles.subButton}
            >
              Add
            </button>
          </div>

          <SortableContext items={section.subsections.map(sub => sub.id)} strategy={verticalListSortingStrategy}>
            {section.subsections.map(sub => (
              <SortableSubsection
                key={sub.id}
                subsection={sub}
                sectionId={section.id}
                getUnitByID={getUnitByID}
                selectedEditorIDs={selectedEditorIDs}
                toggleSelection={toggleSelection}
                lastSelectedEditorIndex={lastSelectedEditorIndex}
                setLastSelectedEditorIndex={setLastSelectedEditorIndex}
                setStructure={setStructure}
                isCollapsed={collapsedSubsections.has(sub.id)}
                toggleCollapse={() => toggleCollapseSubsection(sub.id)}
              />
            ))}
          </SortableContext>
        </>
      )}
    </div>
  )
}

function SortableSubsection({
  subsection,
  sectionId,
  getUnitByID,
  selectedEditorIDs,
  toggleSelection,
  lastSelectedEditorIndex,
  setLastSelectedEditorIndex,
  setStructure,
  isCollapsed,
  toggleCollapse
}) {
  const {
    setNodeRef,
    transform,
    transition,
    attributes,
    listeners,
    isDragging
  } = useSortable({
    id: subsection.id,
    data: { type: 'subsection', parentId: sectionId }
  })

  const allIDs = subsection.unitIDs.map(id => `${subsection.id}__${id}`)

  return (
    <div
      ref={setNodeRef}
      {...attributes}
      {...listeners}
      style={{
        ...styles.subsection,
        transform: CSS.Transform.toString(transform),
        transition,
        opacity: isDragging ? 0.5 : 1
      }}
    >
      <div
        style={styles.subsectionName}
        onClick={toggleCollapse}
      >
        <span style={{ cursor: 'pointer', marginRight: '0.4rem' }}>
          {isCollapsed ? '‚ñ∂' : '‚ñº'}
        </span>
        {subsection.name}
      </div>

      {!isCollapsed && (
        <SortableContext items={allIDs} strategy={verticalListSortingStrategy}>
          <ul style={styles.ul}>
            {subsection.unitIDs.map((uid, index) => {
              const fullID = `${subsection.id}__${uid}`
              const unit = getUnitByID(uid)
              return (
                <SortableUnit
                  key={fullID}
                  id={fullID}
                  uid={uid}
                  fullID={fullID}
                  index={index}
                  ctyp={unit?.CTyp}
                  name={unit?.Content}
                  isSelected={selectedEditorIDs.has(fullID)}
                  selectedEditorIDs={selectedEditorIDs}
                  toggleSelection={toggleSelection}
                  lastSelectedEditorIndex={lastSelectedEditorIndex}
                  setLastSelectedEditorIndex={setLastSelectedEditorIndex}
                  allIDs={allIDs}
                  setStructure={setStructure}
                />
              )
            })}
          </ul>
        </SortableContext>
      )}
    </div>
  )
}

function SortableUnit({
  id,
  uid,
  fullID,
  index,
  ctyp,
  name,
  isSelected,
  selectedEditorIDs,
  toggleSelection,
  lastSelectedEditorIndex,
  setLastSelectedEditorIndex,
  allIDs,
  setStructure
}) {
  const {
    setNodeRef,
    attributes,
    listeners,
    transform,
    transition,
    isDragging
  } = useSortable({
    id,
    data: {
      type: 'unit',
      draggedIDs:
        isSelected && selectedEditorIDs.size > 1
          ? Array.from(selectedEditorIDs).map(x => x.split('__')[1])
          : [uid]
    }
  })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    padding: '0rem 0.2rem',
    backgroundColor: isSelected ? '#2a2a2a' : 'transparent',
    borderLeft: isSelected ? '2px solid #4fc3f7' : '2px solid transparent',
    fontSize: '0.68rem',
    lineHeight: '0.95rem',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '0.02rem',
    cursor: 'grab'
  }

  const handleRemove = (e) => {
    e.stopPropagation()
    setStructure(prev =>
      prev.map(section => ({
        ...section,
        subsections: section.subsections.map(sub =>
          sub.id === fullID.split('__')[0]
            ? { ...sub, unitIDs: sub.unitIDs.filter(id => id !== uid) }
            : sub
        )
      }))
    )
  }

  return (
    <li
      ref={setNodeRef}
      {...attributes}
      {...listeners}
      onClick={(e) => {
        e.stopPropagation()
        toggleSelection(fullID, index, e.shiftKey, allIDs)
      }}
      style={style}
    >
      <span>
        <span style={{ fontWeight: 'bold', color: '#7dd3fc' }}>[{ctyp}]</span>{' '}
        <strong>{uid}</strong>: <span style={{ color: '#bbb' }}>{name}</span>
      </span>
      <button
        onClick={handleRemove}
        style={{
          background: 'transparent',
          color: '#60a5fa',
          border: 'none',
          cursor: 'pointer',
          marginLeft: '0.4rem',
          fontSize: '0.72rem',
          lineHeight: '1rem'
        }}
      >
        ‚úï
      </button>
    </li>
  )
}

const styles = {
  button: {
    backgroundColor: '#333',
    color: '#eee',
    padding: '0.2rem 0.5rem',
    borderRadius: '4px',
    border: 'none',
    fontSize: '0.75rem',
    cursor: 'pointer'
  },
  subButton: {
    backgroundColor: '#222',
    color: '#ccc',
    padding: '0.2rem 0.4rem',
    borderRadius: '3px',
    border: 'none',
    fontSize: '0.72rem',
    cursor: 'pointer'
  },
  section: {
    fontWeight: 'bold',
    marginTop: '1.2rem',
    marginBottom: '0.4rem',
    fontSize: '0.9rem',
    display: 'flex',
    alignItems: 'center',
    cursor: 'pointer'
  },
  subsection: {
    marginLeft: '1rem',
    padding: '0.4rem',
    border: '1px dashed #666',
    borderRadius: '4px',
    backgroundColor: '#1e1e1e',
    marginTop: '0.6rem'
  },
  subsectionName: {
    fontWeight: 'bold',
    marginBottom: '0.2rem',
    fontSize: '0.8rem',
    cursor: 'pointer'
  },
  ul: {
    listStyle: 'none',
    paddingLeft: '0.6rem',
    margin: 0
  }
}









-------------------------------------

App



// src/App.jsx
import { useEffect, useState } from 'react'
import {
  DndContext,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core'

import Sidebar from './components/Sidebar'
import PlaygroundView from './components/PlaygroundView'
import StructureEditor from './components/StructureEditor'

function App() {
  const [units, setUnits] = useState([])
  const [loading, setLoading] = useState(true)
  const [playground, setPlayground] = useState([])
  const [structure, setStructure] = useState([])

  const [selectedPlaygroundIDs, setSelectedPlaygroundIDs] = useState(new Set())
  const [selectedEditorIDs, setSelectedEditorIDs] = useState(new Set())
  const [lastSelectedPlaygroundIndex, setLastSelectedPlaygroundIndex] = useState(null)
  const [lastSelectedEditorIndex, setLastSelectedEditorIndex] = useState(null)

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 5 },
    })
  )

  const normalizeUnitID = (id) => {
    if (id.includes('____drop__')) return id.split('____drop__')[1]
    if (id.includes('__drop__')) return id.split('__drop__')[1]
    if (id.includes('__')) return id.split('__')[1]
    return id
  }

  const handleDragStart = (event) => {
    console.log('üü° Drag Start:', event.active.id)
  }

  const handleDragOver = ({ active, over }) => {
    console.log('üü† Drag Over:', {
      active: active?.id,
      over: over?.id,
    })
  }

  const handleDragEnd = ({ active, over }) => {
    if (!active || !over) return

    const draggedIDs =
      active?.data?.current?.draggedIDs ||
      (selectedPlaygroundIDs.size > 0
        ? Array.from(selectedPlaygroundIDs)
        : selectedEditorIDs.size > 0
        ? Array.from(selectedEditorIDs)
        : [normalizeUnitID(active.id)])

    const targetSubID = over.id.includes('__')
      ? over.id.split('__')[0]
      : over.id

    const targetIndexUnit = over.id.includes('__')
      ? normalizeUnitID(over.id)
      : null

    setStructure(prev =>
      prev.map(section => ({
        ...section,
        subsections: section.subsections.map(sub => {
          let current = [...sub.unitIDs]
          draggedIDs.forEach(id => {
            current = current.filter(u => u !== id)
          })

          if (sub.id !== targetSubID) return { ...sub, unitIDs: current }

          let insertAt = current.length
          if (targetIndexUnit && current.includes(targetIndexUnit)) {
            insertAt = current.indexOf(targetIndexUnit)
            const fromIndex = current.indexOf(draggedIDs[0])
            const toIndex = current.indexOf(targetIndexUnit)
            if (fromIndex < toIndex) insertAt += 1
          }

          const updated = [...current]
          draggedIDs.forEach((id, i) => {
            updated.splice(insertAt + i, 0, id)
          })

          return { ...sub, unitIDs: updated }
        })
      }))
    )

    setSelectedPlaygroundIDs(new Set())
    setSelectedEditorIDs(new Set())
    setLastSelectedPlaygroundIndex(null)
    setLastSelectedEditorIndex(null)
  }

  useEffect(() => {
    fetch('http://127.0.0.1:8000/units')
      .then(res => res.json())
      .then(data => {
        setUnits(data)
        setLoading(false)
      })
      .catch(err => {
        console.error('Fehler beim Laden der Units:', err)
        setLoading(false)
      })
  }, [])

  return (
    <DndContext
      sensors={sensors}
      onDragStart={handleDragStart}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
    >
      <div
        style={{
          display: 'flex',
          height: '100vh',
          width: '100vw',
          backgroundColor: '#1a1a1a',
          color: '#eee',
        }}
      >
        {/* üîπ Sidebar */}
        <div
          style={{
            width: '25%',
            borderRight: '1px solid #333',
            padding: '1rem',
            overflowY: 'auto',
          }}
        >
          <Sidebar
            units={units}
            playground={playground}
            setPlayground={setPlayground}
          />
        </div>

        {/* üîπ Playground */}
        <div
          style={{
            width: '40%',
            padding: '1.5rem',
            overflowY: 'auto',
          }}
        >
          <h2 style={{ marginBottom: '1rem' }}>üìÑ Ausgew√§hlte Einheiten</h2>
          {loading ? (
            <p>‚è≥ Lade Inhalte ‚Ä¶</p>
          ) : (
            <PlaygroundView
              playground={playground}
              setPlayground={setPlayground}
              selectedIDs={selectedPlaygroundIDs}
              setSelectedIDs={setSelectedPlaygroundIDs}
              lastSelectedIndex={lastSelectedPlaygroundIndex}
              setLastSelectedIndex={setLastSelectedPlaygroundIndex}
              units={units} // <‚Äî hier!
            />
          )}
        </div>

        {/* üîπ Struktur-Editor */}
        <div
          style={{
            width: '35%',
            padding: '1.5rem',
            borderLeft: '1px solid #333',
            overflowY: 'auto',
          }}
        >
          <h2 style={{ marginBottom: '1rem' }}>üì¶ Struktur</h2>
          <StructureEditor
            structure={structure}
            setStructure={setStructure}
            selectedEditorIDs={selectedEditorIDs}
            setSelectedEditorIDs={setSelectedEditorIDs}
            lastSelectedEditorIndex={lastSelectedEditorIndex}
            setLastSelectedEditorIndex={setLastSelectedEditorIndex}
            units={units}
          />
        </div>
      </div>
    </DndContext>
  )
}
 
export default App





PlaygoundView

// src/components/PlaygroundView.jsx
import { useDraggable } from '@dnd-kit/core'

export default function PlaygroundView({
  playground,
  setPlayground,
  selectedIDs,
  setSelectedIDs,
  lastSelectedIndex,
  setLastSelectedIndex,
  units,
}) {
  const toggleSelection = (uid, index, shift = false) => {
    setSelectedIDs(prev => {
      const next = new Set(prev)
      if (shift && lastSelectedIndex !== null) {
        const start = Math.min(lastSelectedIndex, index)
        const end = Math.max(lastSelectedIndex, index)
        for (let i = start; i <= end; i++) {
          next.add(playground[i].UnitID)
        }
      } else {
        if (next.has(uid)) {
          next.delete(uid)
        } else {
          next.add(uid)
        }
        setLastSelectedIndex(index)
      }
      return next
    })
  }

  const removeUnit = (uid) => {
    setPlayground(prev => prev.filter(u => u.UnitID !== uid))
    setSelectedIDs(prev => {
      const next = new Set(prev)
      next.delete(uid)
      return next
    })
  }

  const getNameByID = (id) => {
    const entry = units.find(u => u.UnitID === id)
    return entry?.Content || '‚ü®Kein Name‚ü©'
  }

  return (
    <div style={{
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fill, minmax(220px, 1fr))',
      gap: '0.75rem',
    }}>
      {playground.map((unit, index) => (
        <DraggableUnit
          key={unit.UnitID}
          unit={unit}
          index={index}
          isSelected={selectedIDs.has(unit.UnitID)}
          selectedIDs={selectedIDs}
          onRemove={removeUnit}
          onToggle={toggleSelection}
          name={getNameByID(unit.UnitID)}
        />
      ))}
    </div>
  )
}

function DraggableUnit({ unit, index, isSelected, selectedIDs, onRemove, onToggle, name }) {
  const { attributes, listeners, setNodeRef, isDragging } = useDraggable({
    id: `__drop__${unit.UnitID}`,
    data: {
      type: 'unit',
      draggedIDs: isSelected && selectedIDs.size > 1
        ? Array.from(selectedIDs)
        : [unit.UnitID]
    }
  })

  const style = {
    padding: '0.75rem',
    borderRadius: '8px',
    backgroundColor: isSelected ? '#333' : isDragging ? '#2a2a2a' : '#1e1e1e',
    border: isSelected ? '2px solid #4fc3f7' : '1px solid #444',
    color: '#eee',
    display: 'flex',
    flexDirection: 'column',
    gap: '0.25rem',
    cursor: 'grab',
    boxShadow: isSelected ? '0 0 0 2px #4fc3f7 inset' : 'none',
    transition: 'all 0.15s ease',
    minHeight: '100px',
    justifyContent: 'space-between'
  }

  return (
    <div
      ref={setNodeRef}
      {...attributes}
      {...listeners}
      style={style}
      onClick={(e) => {
        e.stopPropagation()
        onToggle(unit.UnitID, index, e.shiftKey)
      }}
    >
      <div style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>{unit.UnitID}</div>
      <div style={{ fontSize: '0.75rem', color: '#aaa' }}>{name}</div>
      <button
        onClick={(e) => {
          e.stopPropagation()
          onRemove(unit.UnitID)
        }}
        style={{
          alignSelf: 'flex-end',
          marginTop: '0.5rem',
          background: 'transparent',
          border: 'none',
          color: '#aaa',
          fontSize: '1rem',
          cursor: 'pointer',
        }}
        title="Entfernen"
      >
        ‚úï
      </button>
    </div>
  )
}






Sidebar


import { useState } from 'react'

export default function Sidebar({ units, playground, setPlayground }) {
  const [expanded, setExpanded] = useState(new Set())  // eingeklappte Topics

  const toggleExpand = (topic) => {
    const newExpanded = new Set(expanded)
    if (expanded.has(topic)) {
      newExpanded.delete(topic)
    } else {
      newExpanded.add(topic)
    }
    setExpanded(newExpanded)
  }

  const isSelected = (uid) => playground.some(p => p.UnitID === uid)

  const handleToggleUnit = (unit) => {
    if (isSelected(unit.UnitID)) {
      setPlayground(playground.filter(p => p.UnitID !== unit.UnitID))
    } else {
      setPlayground([
        ...playground,
        {
          UnitID: unit.UnitID,
          Name: unit.Content, // ‚úÖ Name √ºbernehmen
          Section: "",
          Subsection: "",
          Order: playground.length + 1
        }
      ])
    }
  }

  const handleToggleAll = (unitIDs) => {
    const allSelected = unitIDs.every(id => isSelected(id))

    if (allSelected) {
      setPlayground(playground.filter(p => !unitIDs.includes(p.UnitID)))
    } else {
      const unitsToAdd = units.filter(u => unitIDs.includes(u.UnitID) && !isSelected(u.UnitID))
      const newEntries = unitsToAdd.map((u, i) => ({
        UnitID: u.UnitID,
        Name: u.Content, // ‚úÖ Name √ºbernehmen
        Section: "",
        Subsection: "",
        Order: playground.length + i + 1
      }))
      setPlayground([...playground, ...newEntries])
    }
  }

  // Gruppiere Units nach Subject ‚Üí Topic
  const grouped = {}
  for (const u of units) {
    if (!grouped[u.Subject]) grouped[u.Subject] = {}
    if (!grouped[u.Subject][u.Topic]) grouped[u.Subject][u.Topic] = []
    grouped[u.Subject][u.Topic].push(u)
  }

  return (
    <div style={{ padding: '1rem', width: '300px', backgroundColor: '#111', color: '#eee', fontSize: '0.9rem' }}>
      <h2>Inhalte</h2>
      {Object.entries(grouped).map(([subject, topics]) => {
        const allIdsInSubject = Object.values(topics).flat().map(u => u.UnitID)
        return (
          <div key={subject}>
            <label>
              <input
                type="checkbox"
                checked={allIdsInSubject.every(id => isSelected(id))}
                onChange={() => handleToggleAll(allIdsInSubject)}
              />
              <strong style={{ marginLeft: "0.5rem" }}>{subject}</strong>
            </label>
            <div style={{ paddingLeft: "1rem" }}>
              {Object.entries(topics).map(([topic, units]) => {
                const allIdsInTopic = units.map(u => u.UnitID)
                const isOpen = expanded.has(topic)
                return (
                  <div key={topic}>
                    <label>
                      <input
                        type="checkbox"
                        checked={allIdsInTopic.every(id => isSelected(id))}
                        onChange={() => handleToggleAll(allIdsInTopic)}
                      />
                      <span
                        style={{ cursor: "pointer", marginLeft: "0.5rem" }}
                        onClick={() => toggleExpand(topic)}
                      >
                        {isOpen ? "‚ñº" : "‚ñ∂"} {topic}
                      </span>
                    </label>
                    {isOpen && (
                      <ul style={{ listStyle: "none", paddingLeft: "1.5rem" }}>
                        {units.map(u => (
                          <li key={u.UnitID}>
                            <label>
                              <input
                                type="checkbox"
                                checked={isSelected(u.UnitID)}
                                onChange={() => handleToggleUnit(u)}
                              />
                              <span style={{ marginLeft: "0.5rem" }}>{u.UnitID}: {u.Content}</span>
                            </label>
                          </li>
                        ))}
                      </ul>
                    )}
                  </div>
                )
              })}
            </div>
          </div>
        )
      })}
    </div>
  )
}









StructureEditor



import { useDroppable } from '@dnd-kit/core'
import { SortableContext, useSortable, verticalListSortingStrategy } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

export default function StructureEditor({
  structure,
  setStructure,
  selectedEditorIDs,
  setSelectedEditorIDs,
  lastSelectedEditorIndex,
  setLastSelectedEditorIndex,
  units
}) {
  const toggleEditorSelection = (fullID, index, shift = false, allIDs = []) => {
    setSelectedEditorIDs(prev => {
      const next = new Set(prev)
      if (shift && lastSelectedEditorIndex !== null) {
        const start = Math.min(lastSelectedEditorIndex, index)
        const end = Math.max(lastSelectedEditorIndex, index)
        for (let i = start; i <= end; i++) {
          next.add(allIDs[i])
        }
      } else {
        if (next.has(fullID)) {
          next.delete(fullID)
        } else {
          next.add(fullID)
        }
        setLastSelectedEditorIndex(index)
      }
      return next
    })
  }

  const addSection = () => {
    const name = prompt('Section-Name:')
    if (!name?.trim()) return
    setStructure(prev => [...prev, {
      id: `sec-${Date.now()}`,
      name: name.trim(),
      subsections: []
    }])
  }

  const addSubsection = (secID) => {
    const name = prompt('Subsection-Name:')
    if (!name?.trim()) return
    setStructure(prev =>
      prev.map(sec =>
        sec.id === secID
          ? {
              ...sec,
              subsections: [
                ...sec.subsections,
                {
                  id: `sub-${Date.now()}`,
                  name: name.trim(),
                  unitIDs: []
                }
              ]
            }
          : sec
      )
    )
  }

  const removeUnit = (subID, uid) => {
    setStructure(prev =>
      prev.map(section => ({
        ...section,
        subsections: section.subsections.map(sub =>
          sub.id === subID
            ? { ...sub, unitIDs: sub.unitIDs.filter(id => id !== uid) }
            : sub
        )
      }))
    )
    setSelectedEditorIDs(prev => {
      const next = new Set(prev)
      next.delete(`${subID}__${uid}`)
      return next
    })
  }

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
      <button onClick={addSection}>‚ûï Neue Section</button>
      {structure.map(section => (
        <div key={section.id} style={styles.section}>
          <strong>{section.name}</strong>
          <button onClick={() => addSubsection(section.id)}>‚ûï Subsection</button>
          {section.subsections.map(sub => (
            <DroppableSubsection
              key={sub.id}
              subsection={sub}
              selectedEditorIDs={selectedEditorIDs}
              onRemoveUnit={removeUnit}
              onToggleSelection={toggleEditorSelection}
              lastSelectedEditorIndex={lastSelectedEditorIndex}
              setLastSelectedEditorIndex={setLastSelectedEditorIndex}
              units={units} // ‚úÖ wird weitergegeben
            />
          ))}
        </div>
      ))}
    </div>
  )
}

function DroppableSubsection({
  subsection,
  onRemoveUnit,
  onToggleSelection,
  selectedEditorIDs,
  lastSelectedEditorIndex,
  setLastSelectedEditorIndex,
  units
}) {
  const { setNodeRef, isOver } = useDroppable({
    id: subsection.id,
    data: { subsectionId: subsection.id }
  })

  const allIDs = subsection.unitIDs.map(id => `${subsection.id}__${id}`)

  return (
    <div
      ref={setNodeRef}
      style={{
        ...styles.subsection,
        borderColor: isOver ? '#4fc3f7' : '#777'
      }}
    >
      <strong>{subsection.name}</strong>
      <SortableContext items={allIDs} strategy={verticalListSortingStrategy}>
        <ul style={styles.ul}>
          {subsection.unitIDs.map((uid, index) => {
            const fullID = `${subsection.id}__${uid}`
            const unit = units?.find(u => u.UnitID === uid)
            const name = unit?.Content || '‚ü®Kein Name‚ü©'

            return (
              <SortableUnit
                key={fullID}
                id={fullID}
                uid={uid}
                index={index}
                fullID={fullID}
                allIDs={allIDs}
                isSelected={selectedEditorIDs.has(fullID)}
                selectedEditorIDs={selectedEditorIDs}
                onToggleSelection={(shiftKey) =>
                  onToggleSelection(fullID, index, shiftKey, allIDs)
                }
                onRemove={() => onRemoveUnit(subsection.id, uid)}
                name={name}
              />
            )
          })}
        </ul>
      </SortableContext>
    </div>
  )
}

function SortableUnit({
  id,
  uid,
  index,
  fullID,
  isSelected,
  selectedEditorIDs,
  onToggleSelection,
  onRemove,
  allIDs,
  name
}) {
  const {
    setNodeRef,
    attributes,
    listeners,
    transform,
    transition,
    isDragging
  } = useSortable({
    id,
    data: {
      type: 'unit',
      draggedIDs: isSelected && selectedEditorIDs.size > 1
        ? Array.from(selectedEditorIDs).map(x => x.split('__')[1])
        : [uid]
    }
  })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    display: 'flex',
    justifyContent: 'space-between',
    cursor: 'grab',
    padding: '0.2rem 0',
    border: isSelected ? '1px solid #4fc3f7' : '1px solid transparent',
    backgroundColor: isSelected ? '#333' : 'transparent'
  }

  return (
    <li
      ref={setNodeRef}
      {...attributes}
      {...listeners}
      onClick={(e) => {
        e.stopPropagation()
        onToggleSelection(e.shiftKey)
      }}
      style={style}
    >
      <div>
        <strong>{uid}</strong><br />
        <span style={{ fontSize: '0.75rem', color: '#aaa' }}>{name}</span>
      </div>
      <button onClick={onRemove} style={styles.remove}>‚úï</button>
    </li>
  )
}

const styles = {
  section: {
    border: '1px solid #555',
    borderRadius: '8px',
    padding: '1rem',
    backgroundColor: '#1e1e1e'
  },
  subsection: {
    marginTop: '0.5rem',
    padding: '0.5rem',
    border: '1px dashed #777',
    borderRadius: '4px',
    backgroundColor: '#2a2a2a',
    transition: '0.2s ease all'
  },
  ul: {
    listStyle: 'none',
    paddingLeft: 0,
    marginTop: '0.5rem',
    fontSize: '0.9rem'
  },
  remove: {
    marginLeft: '1rem',
    background: 'transparent',
    border: 'none',
    color: '#aaa',
    cursor: 'pointer'
  }
}
